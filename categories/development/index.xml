<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Development on Espen Braastad</title>
    <link>/categories/development/</link>
    <description>Recent content in Development on Espen Braastad</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 29 May 2016 20:40:48 +0200</lastBuildDate>
    <atom:link href="/categories/development/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Filebin upgrade</title>
      <link>/posts/filebin-upgrade/</link>
      <pubDate>Sun, 29 May 2016 20:40:48 +0200</pubDate>
      <guid>/posts/filebin-upgrade/</guid>
      <description>https://filebin.net is a public and free file upload/sharing service. Its main design principle is to be incredibly simple to use.
It has been in production for several years, and has more or less been unmodified until now. Today it has been upgraded in several ways, and this post aims to elaborate on some of the changes.
Complete rewrite The previous version of Filebin was written in Python and kept meta data in MongoDB.</description>
    </item>
    <item>
      <title>Gofer - Simple notification IRC bot</title>
      <link>/posts/gofer-notification-irc-bot/</link>
      <pubDate>Fri, 08 Jan 2016 21:11:44 +0100</pubDate>
      <guid>/posts/gofer-notification-irc-bot/</guid>
      <description>Gofer is an notification type of IRC bot which is simple to deploy and super easy to integrate with existing services. It serves two main purposes:
Process messages in IRC channels and execute commands to trigger actions based on pre-defined patterns. A good use case is to look for messages matching #\d+ (for example #1337), look up the title and status in a issue tracker and print the information back in the IRC channel:</description>
    </item>
    <item>
      <title>Dummy API, Go rewrite</title>
      <link>/posts/dummy-api-rewrite-in-go/</link>
      <pubDate>Sat, 16 May 2015 19:48:47 +0200</pubDate>
      <guid>/posts/dummy-api-rewrite-in-go/</guid>
      <description>Dummy API was originally written in Lua for running on top of OpenResty. Reasons were high performance and simplicity. The most common Linux distributions do not provide packages for OpenResty in their repositories, which means that it has to be installed from source. This is straight forward, but it adds up - both in time required and extra build dependencies.
The purpose of Dummy API is to be that web application that can be rapidly installed and started when it is necessary to test API managers and web caches with a proper web application.</description>
    </item>
    <item>
      <title>Varnish goes upstack with varnish modules and varnish configuration language</title>
      <link>/posts/varnish-goes-upstack-with-varnish-modules-and-varnish-configuration-language/</link>
      <pubDate>Thu, 07 May 2015 10:55:56 +0200</pubDate>
      <guid>/posts/varnish-goes-upstack-with-varnish-modules-and-varnish-configuration-language/</guid>
      <description>This post was first published at High Scalability.
Varnish Software has just released Varnish API Engine, a high performance HTTP API Gateway which handles authentication, authorization and throttling all built on top of Varnish Cache. The Varnish API Engine can easily extend your current set of APIs with a uniform access control layer that has built in caching abilities for high volume read operations, and it provides real-time metrics.
Varnish API Engine is built using well known components like memcached, SQLite and most importantly Varnish Cache.</description>
    </item>
    <item>
      <title>Dummy API</title>
      <link>/posts/dummy-api/</link>
      <pubDate>Sat, 02 May 2015 21:42:21 +0200</pubDate>
      <guid>/posts/dummy-api/</guid>
      <description>Update: Dummy API has been rewritten in Go.
The purpose of Dummy API to act as a performant, simple and flexible HTTP API to use when testing API gateway performance. Put it behing a API gateway and generate responses to it from a set of consumers/clients. The Dummy API will read the request headers and query parameters and generate the responses accordingly. Some examples are custom cache-control header, response status and response delays.</description>
    </item>
  </channel>
</rss>
